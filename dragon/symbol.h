#ifndef _SYMBOL_H
#define _SYMBOL_H

#include "util.h"
#include "parser.tab.h"
#include "lexer.h"
#include "ast.h"

#define RESOLVE_FAILURE (-1)

#define MAGIC_READ (-2)
#define MAGIC_READLN (-3)
#define MAGIC_WRITE (-4)
#define MAGIC_WRITELN (-5)

#define INTEGER_TYPE_IDX 0
#define REAL_TYPE_IDX 1
#define STRING_TYPE_IDX 2
#define BOOLEAN_TYPE_IDX 3
#define CHAR_TYPE_IDX 4
#define VOID_TYPE_IDX 5

#define ABI_POINTER_SIZE 8
#define ABI_POINTER_ALIGN 8
#define ABI_CLOSURE_SIZE 16
#define ABI_CLOSURE_ALIGN 16

struct stab {
    struct ptrvec *vars, *types;
    // maps from "loc id" to "scope". generated by incrementing 1 for each
    // ast node visited, and kept globally. so when codegen goes to walk the
    // ast later, it can find the scopes necessary.
    struct ptrvec *scopes;
    // a stack of scopes, for use during resolution but freed immediately
    // afterwards (though each individual scope is held onto)
    struct list *chain;
};

// all map from name -> table index
struct stab_scope {
    // variables in scope.
    struct hash_table *vars;
    // functions in scope. uses stab_var, but
    struct hash_table *funcs;
    // types in scope.
    struct hash_table *types;
    int stack_frame_length;
    // non-owning caches. *not* complete, but populated on-demand.
    // struct hash_table *expr_ty_cache, *path_ty_cache;
};

struct insn;

struct stab_var {
    size_t type;
    char *name;
    YYLTYPE *defn; // todo: annotate all AST nodes with a span...
    int disp_offset;
    int stack_base_offset;
    bool captured; // whether this variable needs to be lifted to a closure environment
};

struct stab_resolved_type {
    union {
        struct {
            int lower, upper;
            size_t elt_type;
        } array;
        struct {
            enum subprogs type; // func or proc?
            struct list *args; // arg types
            size_t retty; // ret ty
            bool ret_assigned;
        } func;
        size_t pointer;
        struct {
            struct rec_layout *layout;
            struct list *fields;
        } record;
    };
    enum types tag;
};

struct stab_record_field {
    char *name;
    size_t type;
};

struct stab_type {
    struct stab_resolved_type ty;
    char *name;
    YYLTYPE *defn; // todo
    uint64_t size, align;
    int magic;
};

void stab_enter(struct stab *);
void stab_leave(struct stab *);

struct stab *stab_new();
void stab_free(struct stab *);

void stab_add_decls(struct stab *, struct ast_decls *, int *, bool, bool);
size_t stab_add_var(struct stab *st, char *name, size_t type, YYLTYPE *span, int *, bool);
void stab_add_func(struct stab *, char *, struct ast_type *);
void stab_add_magic_func(struct stab *, int);
void stab_add_type(struct stab *, char *, struct ast_type *);

bool stab_has_local_var(struct stab *, char *);
bool stab_has_local_func(struct stab *, char *);
bool stab_has_local_type(struct stab *, char *);

size_t stab_resolve_var(struct stab *, char *);
size_t stab_resolve_func(struct stab *, char *);
size_t stab_resolve_type(struct stab *, char *, struct ast_type *);
size_t stab_resolve_type_name(struct stab *, char *);

// random crap
bool stab_types_eq(struct stab *, size_t, size_t);
void stab_print_type(struct stab *, size_t, int);

#define STAB_VAR(st, idx) ((struct stab_var *) (st)->vars->data[(idx)])
#define STAB_TYPE(st, idx) ((struct stab_type *) (st)->types->data[(idx)])
#define STAB_FUNC(st, idx) ((struct stab_type *) (st)->types->data[(idx)])

#define CHKRES(type, name, idx) do {\
    if (idx == -1) {\
        span_err("resolution failure! %s `%s` not found", NULL, type, name);\
    } } while(0)
#define CHKREST(i, n) CHKRES("type", n, i)
#define CHKRESV(i, n) CHKRES("variable", n, i)
#define CHKRESF(i, n) CHKRES("subprogram", n, i)

#endif
